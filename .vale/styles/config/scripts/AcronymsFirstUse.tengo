matches := []
defined := {}
reported := {}

allow := {
  // Commonly accepted initialisms in this repo
  "ACE": true,
  "API": true,
  "AST": true,
  "CLI": true,
  "COMMENT": true,
  "CPU": true,
  "CST": true,
  "DATALOG": true,
  "DECIDE": true,
  "DNS": true,
  "DOT": true,
  "DX": true,
  "EBNF": true,
  "EOF": true,
  "ERROR": true,
  "EXTERN": true,
  "GB": true,
  "GPU": true,
  "GUI": true,
  "HTML": true,
  "HTTP": true,
  "HTTPS": true,
  "IDE": true,
  "IDENT": true,
  "IMPLIES": true,
  "INPUT": true,
  "IO": true,
  "IP": true,
  "JSON": true,
  "LICENSE": true,
  "LSP": true,
  "MD": true,
  "MIT": true,
  "OK": true,
  "OS": true,
  "PROGRAM": true,
  "QA": true,
  "RAM": true,
  "README": true,
  "RPC": true,
  "SDK": true,
  "SSH": true,
  "TCP": true,
  "TLS": true,
  "TOML": true,
  "TRUE": true,
  "TYPE": true,
  "UDP": true,
  "UI": true,
  "URL": true,
  "USB": true,
  "UTF": true,
  "UX": true,
  "YAML": true,

  // Token and syntax node identifiers referenced verbatim in docs
  "AND": true,
  "AT": true,
  "ATOM": true,
  "BODY": true,
  "COLON": true,
  "COMMA": true,
  "DECL": true,
  "DEF": true,
  "EQ": true,
  "EQEQ": true,
  "EXPR": true,
  "FALSE": true,
  "FN": true,
  "IMPORT": true,
  "LBRACE": true,
  "LIT": true,
  "LPAREN": true,
  "MINUS": true,
  "RELATION": true,
  "RPAREN": true,
  "NEQ": true,
  "NODE": true,
  "NOT": true,
  "NUMBER": true,
  "OR": true,
  "OUTPUT": true,
  "PERCENT": true,
  "PLUS": true,
  "RBRACE": true,
  "ROOT": true,
  "RULE": true,
  "SLASH": true,
  "STAR": true,
  "STRING": true,
  "STMT": true,
  "TD": true,
  "TYPED": true,
  "WHITESPACE": true,

  // Roman numerals appearing in API names
  "II": true,
  "III": true,
  "IV": true,
  "IX": true,
  "VI": true,
  "VII": true,
  "VIII": true,
  "XI": true,
  "XII": true
}

is_upper := func(ch) { return len(ch) == 1 && ch >= "A" && ch <= "Z" }
is_lower := func(ch) { return len(ch) == 1 && ch >= "a" && ch <= "z" }
is_digit := func(ch) { return len(ch) == 1 && ch >= "0" && ch <= "9" }
is_space := func(ch) { return ch == " " || ch == "\t" || ch == "\n" || ch == "\r" }

is_md_rule := func(word) {
  if len(word) < 3 {
    return false
  }
  if word[:2] != "MD" {
    return false
  }

  idx := 2
  limit := len(word)
  for idx < limit {
    if !is_digit(word[idx:idx+1]) {
      return false
    }
    idx += 1
  }

  return true
}

s := scope
n := len(s)

comment_ranges := []
pos := 0
for pos < n {
  if pos+4 <= n && s[pos:pos+4] == "<!--" {
    end := pos + 4
    closed := false

    for end < n {
      if end+3 <= n && s[end:end+3] == "-->" {
        comment_ranges = append(comment_ranges, {"begin": pos, "end": end + 3})
        pos = end + 3
        closed = true
        break
      }
      end += 1
    }

    if !closed {
      comment_ranges = append(comment_ranges, {"begin": pos, "end": n})
      pos = n
    }

    continue
  }

  pos += 1
}

is_in_comment := func(idx) {
  total := len(comment_ranges)
  current := 0

  for current < total {
    rng := comment_ranges[current]
    if idx >= rng["begin"] && idx < rng["end"] {
      return true
    }
    current += 1
  }

  return false
}

i := 0

for i < n {
  if i+1 > n {
    break
  }

  ch := s[i : i+1]
  if is_upper(ch) {
    j := i
    uppers := 0

    for j < n {
      curr := s[j:j+1]
      if is_upper(curr) {
        uppers += 1
        j += 1
        continue
      }
      if uppers >= 2 && is_digit(curr) {
        j += 1
        continue
      }
      break
    }

    if uppers >= 2 {
      // Skip CamelCase fragments like "DDlog" where the acronym is
      // immediately followed by a lowercase character.
      if j < n && is_lower(s[j:j+1]) {
        i = j
        continue
      }

      base := s[i:j]

      skip := 0
      if j+2 <= n && (s[j:j+2] == "'s" || s[j:j+2] == "â€™s") {
        skip = 2
      } else if j+1 <= n && s[j:j+1] == "s" {
        skip = 1
      }

      if is_md_rule(base) && is_in_comment(i) {
        i = j + skip
        continue
      }

      prev := ""
      k := i - 1
      for k >= 0 {
        prev = s[k:k+1]
        if is_space(prev) {
          k -= 1
          continue
        }
        break
      }

      if prev == "(" {
        defined[base] = true
      } else {
        if !defined[base] && !allow[base] && !reported[base] {
          matches = append(matches, {"begin": i, "end": j})
          reported[base] = true
        }
      }

      i = j + skip
      continue
    }
  }

  i += 1
}

matches
