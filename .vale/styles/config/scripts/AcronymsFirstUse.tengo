matches := []
defined := {}
reported := {}

allow := {
  // Commonly accepted initialisms in this repo
  "ACE": true,
  "API": true,
  "AST": true,
  "CLI": true,
  "COMMENT": true,
  "CPU": true,
  "CST": true,
  "DATALOG": true,
  "DECIDE": true,
  "DNS": true,
  "DOT": true,
  "DX": true,
  "EBNF": true,
  "EOF": true,
  "ERROR": true,
  "EXTERN": true,
  "GB": true,
  "GPU": true,
  "GUI": true,
  "HTML": true,
  "HTTP": true,
  "HTTPS": true,
  "IDE": true,
  "IDENT": true,
  "IMPLIES": true,
  "INPUT": true,
  "IO": true,
  "IP": true,
  "JSON": true,
  "LICENSE": true,
  "LSP": true,
  "MD": true,
  "MIT": true,
  "OK": true,
  "OS": true,
  "PROGRAM": true,
  "QA": true,
  "RAM": true,
  "README": true,
  "RPC": true,
  "SDK": true,
  "SSH": true,
  "TCP": true,
  "TLS": true,
  "TOML": true,
  "TRUE": true,
  "TYPE": true,
  "UDP": true,
  "UI": true,
  "URL": true,
  "USB": true,
  "UTF": true,
  "UX": true,
  "YAML": true,

  // Token and syntax node identifiers referenced verbatim in docs
  "AND": true,
  "AT": true,
  "ATOM": true,
  "BODY": true,
  "COLON": true,
  "COMMA": true,
  "DECL": true,
  "DEF": true,
  "EQ": true,
  "EQEQ": true,
  "EXPR": true,
  "FALSE": true,
  "FN": true,
  "IMPORT": true,
  "LBRACE": true,
  "LIT": true,
  "LPAREN": true,
  "MINUS": true,
  "RELATION": true,
  "RPAREN": true,
  "NEQ": true,
  "NODE": true,
  "NOT": true,
  "NUMBER": true,
  "OR": true,
  "OUTPUT": true,
  "PERCENT": true,
  "PLUS": true,
  "RBRACE": true,
  "ROOT": true,
  "RULE": true,
  "SLASH": true,
  "STAR": true,
  "STRING": true,
  "STMT": true,
  "TD": true,
  "TYPED": true,
  "WHITESPACE": true,

  // Roman numerals appearing in API names
  "II": true,
  "III": true,
  "IV": true,
  "IX": true,
  "VI": true,
  "VII": true,
  "VIII": true,
  "XI": true,
  "XII": true
}

is_upper := func(ch) { return len(ch) == 1 && ch >= "A" && ch <= "Z" }
is_lower := func(ch) { return len(ch) == 1 && ch >= "a" && ch <= "z" }
is_digit := func(ch) { return len(ch) == 1 && ch >= "0" && ch <= "9" }
is_space := func(ch) { return ch == " " || ch == "\t" || ch == "\n" || ch == "\r" }

is_md_rule := func(word) {
  if len(word) < 3 {
    return false
  }
  if word[:2] != "MD" {
    return false
  }

  idx := 2
  limit := len(word)
  for idx < limit {
    if !is_digit(word[idx:idx+1]) {
      return false
    }
    idx += 1
  }

  return true
}

s := scope
n := len(s)

comment_ranges := []
ignore_ranges := []

add_ignore_range := func(begin, end) {
  ignore_ranges = append(ignore_ranges, {"begin": begin, "end": end})
}

ignore_range_end := func(idx) {
  total := len(ignore_ranges)
  current := 0

  for current < total {
    rng := ignore_ranges[current]
    if idx >= rng["begin"] && idx < rng["end"] {
      return rng["end"]
    }
    current += 1
  }

  return -1
}

pos := 0
for pos < n {
  if pos+4 <= n && s[pos:pos+4] == "<!--" {
    end := pos + 4
    closed := false

    for end < n {
      if end+3 <= n && s[end:end+3] == "-->" {
        comment_ranges = append(comment_ranges, {"begin": pos, "end": end + 3})
        pos = end + 3
        closed = true
        break
      }
      end += 1
    }

    if !closed {
      comment_ranges = append(comment_ranges, {"begin": pos, "end": n})
      pos = n
    }

    continue
  }

  pos += 1
}

is_in_comment := func(idx) {
  total := len(comment_ranges)
  current := 0

  for current < total {
    rng := comment_ranges[current]
    if idx >= rng["begin"] && idx < rng["end"] {
      return true
    }
    current += 1
  }

  return false
}

line_start := 0
in_fence := false
fence_char := ""
fence_count := 0
fence_begin := 0

for line_start < n {
  line_end := line_start
  for line_end < n && s[line_end:line_end+1] != "\n" {
    line_end += 1
  }

  content_idx := line_start
  for content_idx < line_end {
    ch_line := s[content_idx:content_idx+1]
    if ch_line != " " && ch_line != "\t" {
      break
    }
    content_idx += 1
  }

  if !in_fence {
    if content_idx < line_end {
      fence_candidate := s[content_idx:content_idx+1]
      if fence_candidate == "`" || fence_candidate == "~" {
        candidate_idx := content_idx
        count := 0
        for candidate_idx < line_end && s[candidate_idx:candidate_idx+1] == fence_candidate {
          count += 1
          candidate_idx += 1
        }
        if count >= 3 {
          in_fence = true
          fence_char = fence_candidate
          fence_count = count
          fence_begin = line_start
        }
      }
    }
  } else {
    if content_idx < line_end {
      fence_candidate := s[content_idx:content_idx+1]
      if fence_candidate == fence_char {
        candidate_idx := content_idx
        count := 0
        for candidate_idx < line_end && s[candidate_idx:candidate_idx+1] == fence_char {
          count += 1
          candidate_idx += 1
        }
        if count >= fence_count {
          fence_end := line_end
          if line_end < n {
            fence_end += 1
          }
          add_ignore_range(fence_begin, fence_end)
          in_fence = false
        }
      }
    }
  }

  if line_end >= n {
    line_start = n
  } else {
    line_start = line_end + 1
  }
}

if in_fence {
  add_ignore_range(fence_begin, n)
}

inline_pos := 0
for inline_pos < n {
  skip_inline := ignore_range_end(inline_pos)
  if skip_inline != -1 {
    if skip_inline <= inline_pos {
      inline_pos += 1
    } else {
      inline_pos = skip_inline
    }
    continue
  }

  if inline_pos+1 <= n && s[inline_pos:inline_pos+1] == "`" {
    j := inline_pos
    ticks := 0
    for j < n && s[j:j+1] == "`" {
      ticks += 1
      j += 1
    }

    if ticks > 0 {
      search := j
      found := false
      for search < n {
        skip_search := ignore_range_end(search)
        if skip_search != -1 {
          if skip_search <= search {
            search += 1
          } else {
            search = skip_search
          }
          continue
        }

        if search+1 <= n && s[search:search+1] == "`" {
          k := search
          count := 0
          for k < n && s[k:k+1] == "`" {
            count += 1
            k += 1
          }
          if count == ticks {
            add_ignore_range(inline_pos, k)
            inline_pos = k
            found = true
            break
          }
          search = k
          continue
        }

        search += 1
      }

      if found {
        continue
      }
    }
  }

  inline_pos += 1
}

i := 0

for i < n {
  if i+1 > n {
    break
  }

  skip := ignore_range_end(i)
  if skip != -1 {
    if skip <= i {
      i += 1
    } else {
      i = skip
    }
    continue
  }

  ch := s[i : i+1]
  if is_upper(ch) {
    j := i
    uppers := 0

    for j < n {
      curr := s[j:j+1]
      if is_upper(curr) {
        uppers += 1
        j += 1
        continue
      }
      if uppers >= 2 && is_digit(curr) {
        j += 1
        continue
      }
      break
    }

    if uppers >= 2 {
      // Skip CamelCase fragments like "DDlog" where the acronym is
      // immediately followed by a lowercase character.
      if j < n && is_lower(s[j:j+1]) {
        i = j
        continue
      }

      base := s[i:j]

      skip := 0
      if j+2 <= n && (s[j:j+2] == "'s" || s[j:j+2] == "â€™s") {
        skip = 2
      } else if j+1 <= n && s[j:j+1] == "s" {
        skip = 1
      }

      if is_md_rule(base) && is_in_comment(i) {
        i = j + skip
        continue
      }

      prev := ""
      k := i - 1
      for k >= 0 {
        prev = s[k:k+1]
        if is_space(prev) {
          k -= 1
          continue
        }
        break
      }

      if prev == "(" {
        defined[base] = true
      } else {
        if !defined[base] && !allow[base] && !reported[base] {
          matches = append(matches, {"begin": i, "end": j})
          reported[base] = true
        }
      }

      i = j + skip
      continue
    }
  }

  i += 1
}

matches
